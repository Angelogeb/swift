// RUN: %target-sil-opt %s -infer-effects | %FileCheck %s

sil_stage canonical

import Builtin
import Swift

class List {
  var x: Int
  let next: List
}

struct S {
  var l: List
  var y: Int
}

struct Ptr {
  var p: Int64
}

// CHECK-LABEL: sil [sideeffects _(?), r(%0)] [ossa] @readIdentifiedArg
sil [ossa] @readIdentifiedArg : $@convention(thin) (@in Int) -> Int {
bb0(%0 : $*Int):
  %res = load [trivial] %0 : $*Int
  return %res : $Int
}

// CHECK-LABEL: sil [sideeffects _(?), w(%0)] [ossa] @writeIdentifiedArg
sil [ossa] @writeIdentifiedArg : $@convention(thin) (@inout Int) -> () {
bb0(%0 : $*Int):
  %2 = integer_literal $Builtin.Int64, 42
  %3 = struct $Int (%2 : $Builtin.Int64)
  store %3 to [trivial] %0 : $*Int
  %5 = tuple ()
  return %5 : $()
}

// CHECK-LABEL: sil [sideeffects _(?), w(%0.s0.c0)] [ossa] @$writeToHead
sil [ossa] @$writeToHead : $@convention(thin) (@guaranteed S) -> () {
bb0(%0 : @guaranteed $S):
  debug_value %0 : $S, let, name "s", argno 1
  %2 = struct_extract %0 : $S, #S.l
  %3 = integer_literal $Builtin.Int64, 10
  %4 = struct $Int (%3 : $Builtin.Int64)
  %5 = begin_borrow [lexical] %2 : $List
  %6 = ref_element_addr %5 : $List, #List.x
  %7 = begin_access [modify] [dynamic] %6 : $*Int
  store %4 to [trivial] %7 : $*Int
  end_access %7 : $*Int
  end_borrow %5 : $List
  %11 = tuple ()
  return %11 : $()
}

// CHECK-LABEL: sil [sideeffects _(?), w(%0.c0), w(%1.c0)] [ossa] @storeToArgs
sil [ossa] @storeToArgs : $@convention(thin) (@guaranteed List, @guaranteed List) -> () {
bb0(%1 : @guaranteed $List, %2 : @guaranteed $List):
  cond_br undef, bb1, bb2

bb1:
  %8 = integer_literal $Builtin.Int64, 10
  %9 = struct $Int (%8 : $Builtin.Int64)
  %10 = ref_element_addr %1 : $List, #List.x
  %11 = begin_access [modify] [dynamic] %10 : $*Int
  store %9 to [trivial] %11 : $*Int
  end_access %11 : $*Int
  %14 = tuple ()
  br bb3

bb2:
  %16 = integer_literal $Builtin.Int64, 20
  %17 = struct $Int (%16 : $Builtin.Int64)
  %18 = ref_element_addr %2 : $List, #List.x
  %19 = begin_access [modify] [dynamic] %18 : $*Int
  store %17 to [trivial] %19 : $*Int
  end_access %19 : $*Int
  %22 = tuple ()
  br bb3

bb3:
  %24 = tuple ()
  return %24 : $()
}

// Path becomes "**" because store is on `x` while
// retain release are on the reference itself
// CHECK-LABEL: sil [sideeffects _(?), w+-(%0.**)] @storeMaybeLocalPhi
sil @storeMaybeLocalPhi : $@convention(thin) (@guaranteed List) -> () {
bb0(%1 : $List):
  cond_br undef, bb1, bb2

bb1:
  strong_retain %1 : $List
  br bb3(%1 : $List)

bb2:
  %10 = alloc_ref $List
  br bb3(%10 : $List)

bb3(%12 : $List):
  %14 = integer_literal $Builtin.Int64, 20
  %15 = struct $Int (%14 : $Builtin.Int64)
  %16 = ref_element_addr %12 : $List, #List.x
  %17 = begin_access [modify] [dynamic] %16 : $*Int
  store %15 to %17 : $*Int
  end_access %17 : $*Int
  %20 = tuple ()
  strong_release %12 : $List
  %22 = tuple ()
  return %22 : $()
}

// CHECK-LABEL: sil [sideeffects _(?), w(%0.s0)] [ossa] @testStructPhiCommon
sil [ossa] @testStructPhiCommon : $@convention(thin) (@inout Ptr) -> () {
bb0(%0 : $*Ptr):
  %2 = struct_element_addr %0 : $*Ptr, #Ptr.p
  cond_br undef, bb1, bb2

bb1:
  %3 = address_to_pointer %2 : $*Int64 to $Builtin.RawPointer
  br bb3(%3 : $Builtin.RawPointer)

bb2:
  %5 = address_to_pointer %2 : $*Int64 to $Builtin.RawPointer
  br bb3(%5 : $Builtin.RawPointer)

bb3(%6 : $Builtin.RawPointer) :
  %7 = pointer_to_address %6 : $Builtin.RawPointer to $*Int64
  %8 = integer_literal $Builtin.Int64, 2
  %9 = struct $Int64 (%8 : $Builtin.Int64)
  store %9 to [trivial] %7 : $*Int64
  %22 = tuple ()
  return %22 : $()
}

// CHECK-LABEL: sil [sideeffects _(?), w(%0.s0.c0)] [ossa] @calleeWriteToHead
sil [ossa] @calleeWriteToHead : $@convention(thin) (@guaranteed S) -> () {
bb0(%0 : @guaranteed $S):
  debug_value %0 : $S, let, name "s", argno 1
  %2 = struct_extract %0 : $S, #S.l
  %3 = integer_literal $Builtin.Int64, 10
  %4 = struct $Int (%3 : $Builtin.Int64)
  %5 = begin_borrow [lexical] %2 : $List
  %6 = ref_element_addr %5 : $List, #List.x
  %7 = begin_access [modify] [dynamic] %6 : $*Int
  %writeArg = function_ref @writeIdentifiedArg : $@convention(thin) (@inout Int) -> ()
  %app = apply %writeArg(%7) : $@convention(thin) (@inout Int) -> ()
  end_access %7 : $*Int
  end_borrow %5 : $List
  %11 = tuple ()
  return %11 : $()
}

// CHECK-LABEL: sil [sideeffects w(?), w(%0)] [ossa] @has_partial_apply
sil [ossa] @has_partial_apply : $@convention(thin) (@guaranteed List) -> () {
bb0(%0 : @guaranteed $List):
  %f = function_ref @storeToArgs : $@convention(thin) (@guaranteed List, @guaranteed List) -> ()
  %clo = partial_apply [callee_guaranteed] [on_stack] %f(%0) : $@convention(thin) (@guaranteed List, @guaranteed List) -> ()
  %res = apply %clo(%0) : $@noescape @callee_guaranteed (@guaranteed List) -> ()
  dealloc_stack %clo : $@noescape @callee_guaranteed (@guaranteed List) -> ()
  %r = tuple()
  return %r : $()
}

// CHECK-LABEL: sil [sideeffects _(?), r(%0.c0)] [ossa] @readIdentifiedBoxArg
sil [ossa] @readIdentifiedBoxArg : $@convention(thin) (@guaranteed { var Int }) -> Int {
bb0(%0 : @guaranteed ${ var Int }):
  %1 = project_box %0 : ${ var Int }, 0
  %5 = begin_access [read] [dynamic] %1 : $*Int
  %6 = load [trivial] %5 : $*Int
  end_access %5 : $*Int
  return %6 : $Int
}
